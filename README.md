# Dijkstra Algorithm(다익스트라 알고리즘)
#### 다이나믹 프로그래밍 기법(동적 프로그래밍)을 활용하였다.

#### 하지만 분류는 다이나믹 프로그래밍으로 분류될 수도 있고, 그리디 알고리즘으로 분류될 수도 있다.

* 여기서 다이나믹 프로그래밍은 큰 문제를 한 번에 해결하기 힘들 때 작은 문제들로 나눠서 푸는 프로그래밍 기법이다.
  * 다익스트라에서는 A에서 D로 가는 길이 A-B B-C C-D로 가는 경로가 최단 경로라면! A-B B-C로 가는 경로도 최단 경로가 되어야 한다. 그 값들을 매번 재계산 하지 않고, 저장 해뒀다가 재사용하기 때문에 다이나믹(동적) 프로그래밍이라고 할 수 있다.
* 여기서 그리디 알고리즘은 탐욕스러운, 욕심 많은 이라는 뜻이다. 말 그대로 선택의 순간마다 당장 눈 앞에 보이는 최적의 상황만을 쫓아서 최종적인 해답에 도달하는 알고리즘이다.



#### 알고리즘의 정의

* 다이나믹 프로그래밍을 활용한 대표적인 최단 경로 탐색 알고리즘.



#### 알고리즘의 목적

* 최단 경로 탐색



#### 우리 주위에서 볼 수 있는 대표적으로 쓰이는 곳

* 인공위성
* GPS
* 소프트웨어



#### 방법

* "특정한" 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려준다.



#### 알고리즘의 특징

* 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다.
* 다익스트라는 그리디 알고리즘, 다이나믹 프로그래밍으로 분류된다.



#### 알고리즘의 단점

* 음의 간선을 포함할 수 없다. => 현실은 사이의 거리가 마이너스 값이 나올 수 없기에,  GPS 같은 곳에 사용하기 적합하다.



#### 각 정점으로 가는 노드 사이 간선을 이차원 배열 형태인 표로 만들어보겠습니다. A를 출발 노드로 설정합니다.

#### 각 정점([1], [2], [3], [4], [5], [6], [7])으로 향하는 비용 (0, 3, 4, INF, INF, INF, INF)을 기록합니다. 

#### 여기서 가장 비용이 적은 간선인 [1]-[2]를 선택했습니다. [2]노드를 선택합니다.

#### [2]노드를 거쳐서 가는 경우를 모두 고려합니다. [2]-[6]로 [1]-[6](INF)보다 [1]-[2]-[6](8)가 더 최소 비용으로, 배열을 갱신해줍니다.

#### 이런 식으로 반복해서 배열을 갱신해줍니다. 예를 들어 [1]에서 [5]로 바로 가는 길이 없다면 위에서 구해 저장했던 [1]-[2]-[6]-[5] 최소 비용값을 이용해 [6]에 연결된 노드인 [5]로 가는 최종 최소 비용을 구할 수 있는 것입니다.

#### 이렇게 최소 비용이 나오며 갱신된다.

#### 한마디로, 현재까지 알고 있던 최단 경로를 계속해서 갱신 해주는 이것이 다익스트라 알고리즘이다.



#### 알고리즘의 과정

1. 출발 노드 설정
2. 출발 노드를 기준 정점으로 각 다른 정점인 노드의 최소 비용을 저장
3. 방문하지 않은 노드 중 가장 비용이 적은 노드 선택
4. 해당 노드를 거쳐서 목표가 되는 노드로 가는 경우를 고려해 최소 비용 갱신
5. 3~4번 반복



#### 알고리즘의 방법

* 첫번째 알고리즘인 선형 탐색은 차례대로 즉 순차적으로 배열을 순환하는 방식이다. 위 알고리즘은 최소 비용을 단순히 선형 탐색으로 찾도록 만들었다. 
* [시간 복잡도 = O(N^2)] 빠르게 작동시켜야하면 힙 구조를 활용하여 시간 복잡도 O(N*log N)을 만들 수 있다. 
* 위 알고리즘을 사용할 시, 정점의 갯수가 많은데 간선은 적을 때 치명적일 정도로 비효율일 수 있다.



* 두 번째 알고리즘인 인접 리스트는 인접 리스트의 방식을 활용하여 시간 복잡도를 O(N * log N)으로 구현한 것이다. 
* 이 알고리즘은 정점에 비해 간선의 갯수가 비정상적으로 적어도 선형 탐색과는 다르게 안정적으로 처리할 수 있다.
